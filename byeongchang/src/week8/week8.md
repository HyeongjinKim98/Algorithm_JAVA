# [1629 : 곱셈](https://www.acmicpc.net/problem/1629)
### 필요한 지식
* (a\*b)\%c = (a\%c)\*(b\%c)\%c
* N = 2\*n(짝수), N = 2\*n+1(홀수)
* 분할 정복 : 동일한 유형의 작은 문제의 결과 값을 구하고 합쳐서 원래 문제의 답을 구하는 방법
### 생각한 방법
1. B를 작은 단위로 분할 ex) 10 -> 5+5 -> 2+2+1 -> 1
2. 가장 작은 단위부터 나머지 연산((a\*b)%c = (a%c)\*(b%c)%c)해서 리턴(재귀 활용)
3. 리턴받은 값을 이용해 현재 단위 계산 ex) 1 -> 2: 2\*1 -> 5: 2\*2+1 -> 10: 5\*2
4. +1이 붙은 단위에서는 나머지 연산에 추가로 A%C 결과값을 곱함 ex) 3: 2\*1+1, 4: 2\*2 
 
<br> 
<hr>
<br>

# [12100 : 2048(Easy)](https://www.acmicpc.net/problem/12100)
### 필요한 지식
* 중복 순열
### 생각한 방법
1. 중복순열을 이용해 이동 가능한 모든 경우의 수 구함
    * 4^5 = 1024 이므로 모든 경우의 수는 1024임
2. 정해진 경우의 수에 따라 위, 아래, 왼쪽, 오른쪽으로 이동 연산한 후, 보드의 최대값 갱신
   *  각 방향의 반대 방향(위: 위->아래 방향, 아래: 아래->위 방향, 왼쪽: 왼쪽->오른쪽 방향, 오른쪽: 오른쪽->왼쪽 방향)으로 연산해야 결과 값이 원하는 방향으로 이동한 것처럼 보임
   1. 보드의 칸을 하나 선택
   2. 칸이 비었을 경우 반대 방향으로 탐색하다가 숫자가 있는 칸을 발견하면 숫자를 자신의 칸으로 이동시키고 탐색 종료
   3. 칸에 숫자가 존재할 경우 반대 방향으로 탐색하다가 숫자가 있는 칸을 발견할 경우 자신의 칸과 숫자를 비교함
   4. 숫자가 같은 경우 숫자를 합치고 탐색 종료
   5. 숫자가 다를 경우 탐색 종료
   6. 탐색 종료 후 선택한 칸의 숫자가 최대값을 저장한 변수의 숫자보다 크면 최대값 변수 갱신
   7. 위 연산을 보드의 모든 칸에 반복 수행
 
<br> 
<hr>
<br>

# [14676 : 영우는 사기꾼](https://www.acmicpc.net/problem/14676)
### 필요한 지식
*  없음
### 생각한 방법
1. 건물을 짓기 위한 조건이 되는 건물 리스트(조건 리스트), 건물이 다른 건물을 건설에 영향을 주는 리스트(영향 리스트)를 만들어 건물 관계를 입력 받아 두 개의 리스트에 저장
2. 입력 받은 게임 정보가 건설인 경우
   1. 조건이 되는 건물이 모두 지어졌는지 확인
   2. 건설가능하면 지금까지 지어진 건물 개수 + 1 (건물은 여러 개 건설될 수 있음)
   3. 건설 불가능하면 치트를 사용된 것이므로 King-God-Emperor 출력 후 종료
3. 입력 받은 게임 정보가 파괴인 경우
   1. 지금까지 지어진 건물 개수 - 1
   2. 지어진 건물 개수가 음수가 되는 경우 치트가 사용된 것이므로 King-God-Emperor 출력 후 종료